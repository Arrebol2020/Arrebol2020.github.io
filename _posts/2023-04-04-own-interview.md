---
layout: post
title: C++ 后端面经记录
date: 2023-04-04 16:48 +0800
categories:
- 个人成长
tag:
- C++ 面经
---



本文将记录我阅读别人面经/自己面经记录自己不懂的问题，方便以后巩固。



## WebServer 项目

### 介绍下项目

- 服务器开始运行，创建（初始化）线程池（I/O密集型，线程数 n + 1）
- 创建 epoll 对连接进行监听
- 监听到连接事件，调用线程池处理 http 请求
- 读取 http 请求并对其进行解析（空格，\r\n 字段提取）
- 返回解析结果



### 为什么选择 epoll

select ：有数量限制（1024）、每次调用需要将 fd 从用户态拷贝到内核态、需要遍历所有的 fd 才知道哪个有事件发生

poll ：链表没有数量限制，每次调用需要将 fd 从用户态拷贝到内核态、需要遍历所有的 fd 才知道哪个有事件发生

epoll：红黑树增删改综合效率高，有就绪的描述符的链表。当有的连接就绪的时候，不用去遍历整棵树



## C++

### C++ 空类的大小？一个只包含int 变量的空class和只包含int变量的空struct的内存各占多大？

- 空类和空结构体大小都为 1 字节，这样可以确保两个不同的对象，拥有不同的地址

- 含有虚函数的类的大小 4 字节，因为虚函数类对象中都有一个虚函数指针 __vptr，其大小是 4 字节

  ```c++
  class A { virtual Fun(){} };
  int main(){
    cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);
    A a; 
    cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);
    return 0;
  }
  ```

- 只含有一个 int 成员变量的类的大小

  ```c++
  class A { int a; };
  int main(){
    cout<<sizeof(A)<<endl;// 输出 4;
    A a; 
    cout<<sizeof(a)<<endl;// 输出 4;
    return 0;
  }
  ```

- 只含有一个静态成员变量的类大小为 1 字节，因为静态成员变量存放在静态存储去，不占用类的大小，普通函数也不占用类大小

  ```c++
  class A { static int a; };
  int main(){
    cout<<sizeof(A)<<endl;// 输出 1;
    A a; 
    cout<<sizeof(a)<<endl;// 输出 1;
    return 0;
  }
  ```



### 为什么一般构造函数定义为虚函数？

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄露。

所以在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。



###  为什么构造函数不写为虚构函数？

从存储空间角度：虚函数对应一个vtable，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。

从使用角度：虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。



### static

不考虑类的情况：

- 有时候希望某些全局变量或者函数只在本文件中被使用，而不能被其他外部文件引用，这个时候可以在全局变量前加一个 static
- 默认初始化为 0，`未初始化的全局静态变量与局部静态变量`，都存在全局未初始化区
- 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用域与局部变量相同，函数退出后仍然存在，但是不能使用

考虑类的情况：

- static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，**必须在类定义体外部初始化**，初始化时不需要标示为static；可以被非static成员函数任意访问。
- static成员函数：**不具有this指针**，**无法访问类对象的非static成员变量**和**非static成员函数**；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问



### 静态局部变量

- 静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在整个程序运行期间始终存在。

- 静态局部变量只初始化一次，并且之后再次调用函数时不再重新分配空间和赋初值，而保留上次函数调用结束时的值（而普通局部变量每调用一次就会重新分配空间并赋一次初值）

- 静态局部变量默认初始化为0

- 函数调用结束之后静态局部变量依然存在，但是只能在该函数内进行使用该静态局部变量



### extern 的作用

- 将全局变量的作用域扩展到其定义之前：如果全局变量不在文件的开头定义，其作用范围只限定于从定义处到文件结尾，如果在定义点之前的函数想引用该变量，就应该在引用之前使用extern关键字对该变量进行声明，之后该全局变量的作用域就从声明处一直到文件结尾了

- 将某一个源文件中全局变量的作用域扩展到其他源文件中：一个C++项目很多情况是由多个源文件构成，如果在一个文件中想引用另一个文件中已定义的全局变量，比如现在两个文件都要使用到同一个全局变量int a，正确的做法应该是：在一个文件中定义变量a，而在另一个文件中使用extern int a；对该变量进行声明，这样就可以两个文件同时使用同一个变量了



### const 作用

不考虑类的情况

- **const常量在定义时必须初始化**，之后无法更改
- **const形参可以接收const和非const类型的实参**，例如// i 可以是 int 型或者 const int 型void fun(const int& i){ //...}

考虑类的情况

- **const成员变量**：不能在类定义外部初始化，**只能通过构造函数初始化列表进行初始化，并且必须有构造函数**；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化。
- const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值。



### C++ sort() 函数

- 判断元素个数是否小于 stl_threshold （16），小于则使用插入排序
- 大于判断能不能使用快速排序（判断递归深度有没有达到递归深度的限制 2*lg(n)），没有则使用快速排序
- 超过则使用堆排序，稳定 O(nlogn) 的时间复杂度



- 















## 操作系统

### 线程和进程的区别

- 进程是资源的分配单位，线程是 CPU 的调度单位
- 进程拥有一个独立完整的资源平台，不与其他进程共享；线程只独享必不可少的资源，如寄存器和栈，而一个进程可以有多个线程，彼此共享同一个地址空间
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系
- 线程能减少并发执行的时间和空间开销

对于，线程相比进程能减少开销，体现在：

- （1. **创建时间少**）线程的**创建时间**比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存、文件管理信息**切换虚拟地址空间，切换内核栈和硬件上下文，**页表切换开销很大**，而线程在创建的过程中，不会涉及这些信息，而是共享它们，**只需保存和设置少量寄存器内容，因此开销很小；
- （2. **终止时间少**）线程的**终止时间**比进程快，因为线程释放的资源相比进程少很多；
- （3. **不需要切换页表，切换时间块**）同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- （4. **共享、线程之间数据传递效率高**）由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

所以，不管是时间效率，还是空间效率线程比进程都要高

心得：线程使用有一定难度，需要处理数据一致性问题，比如要使用互斥锁和条件变量等同步机制保证线程安全（原子性操作）



## 参考

- https://mp.weixin.qq.com/s/9XmrE51zsQhRw19WqlmgbA
- 

## 写在最后

感谢你在茫茫人海中找到我🕵🏼

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<span id="busuanzi_container_page_pv">🎉你是第 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i>  </span> 个读者

㊗️ 你平安喜乐，顺遂无忧！

希望你读完有所收获～

🥂🥂🥂 
